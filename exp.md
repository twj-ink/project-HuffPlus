1. 第一阶段：
* #pragma once 是一种简洁有效的方法来确保**头文件在一个编译单元中只被包含一次**，避免重复包含的问题。它相对于传统的宏保护方式更为简洁，且不会存在宏名称冲突的风险。
* std::istream 并不仅限于命令行输入，它是一个泛化的输入流接口，可以从各种数据源读取数据。ifstream是派生类，从文件中读取；cin是它的全局对象，从标准输入中读取数据；istringstream是派生类，从字符串中读取数据。在统一接口中直接用istream& in统一输入，使用getline等等解析即可。
* 传递引用：防止复制；流对象可变，方便修改（所以不要加const）
* 在基类ICompressor中，函数都是纯虚函数，要求每一类压缩算法都要严格声明
* 虚拟析构函数的作用：当你使用**基类指针来删除派生类对象**时，虚拟析构函数确保 派生类的析构函数 会被正确调用，从而释放派生类的资源。`= default` 关键字表示使用编译器自动生成的析构函数，这样简化代码，但仍然能保证资源管理的正确性。
* 思考：统一接口的好处是统一使用方式，必须提供统一的压缩和解压缩这两个标准功能；基类定义public，每个派生类自己的内容放到private中，**封装** 是面向对象编程的一个基本特性，目的是通过限制外部代码对类成员的直接访问，来保护类的内部数据和逻辑。通过将派生类的成员放入 private 区域，可以确保外部代码只能通过公开的接口（public 函数）来与派生类对象交互，而不能直接访问或修改类的内部数据；**控制访问权限**：派生类的成员变量和实现细节放在 private 区域，外部代码不能直接修改它们，只能通过公开的接口进行操作。这样可以避免外部代码对派生类数据的不安全访问或修改。
* 处理大文件时：如果你要处理的是非常大的文件或大量的数据，使用 rdbuf() 将数据读入缓冲区是更好的选择，因为它减少了重复的 I/O 操作，提高了速度。直接从 in 逐步读取数据可能会导致频繁的磁盘访问，而从缓冲区读取则避免了这个问题。
* 在.cpp中写.h的函数实现时，在函数名上把类写上，这样内部的变量就可以自动找到所属的类了。
* 